import math 
import numpy as np

import torch
from torch import nn


"""
Utility functions to deal with model parameters. 
Mostly copy-paste from the dino repo:
https://github.com/facebookresearch/dino/blob/main/utils.py
"""


def _no_grad_trunc_normal_(tensor, mean, std, a, b):
    # Cut & paste from PyTorch official master until it's in a few official releases - RW
    # Method based on https://people.sc.fsu.edu/~jburkardt/presentations/truncated_normal.pdf
    def norm_cdf(x):
        # Computes standard normal cumulative distribution function
        return (1. + math.erf(x / math.sqrt(2.))) / 2.

    if (mean < a - 2 * std) or (mean > b + 2 * std):
        warnings.warn("mean is more than 2 std from [a, b] in nn.init.trunc_normal_. "
                      "The distribution of values may be incorrect.",
                      stacklevel=2)

    with torch.no_grad():
        # Values are generated by using a truncated uniform distribution and
        # then using the inverse CDF for the normal distribution.
        # Get upper and lower cdf values
        l = norm_cdf((a - mean) / std)
        u = norm_cdf((b - mean) / std)

        # Uniformly fill tensor with values from [l, u], then translate to
        # [2l-1, 2u-1].
        tensor.uniform_(2 * l - 1, 2 * u - 1)

        # Use inverse cdf transform for normal distribution to get truncated
        # standard normal
        tensor.erfinv_()

        # Transform to proper mean, std
        tensor.mul_(std * math.sqrt(2.))
        tensor.add_(mean)

        # Clamp to ensure it's in the proper range
        tensor.clamp_(min=a, max=b)
        return tensor


def trunc_normal_(tensor, mean=0., std=1., a=-2., b=2.):
    # type: (Tensor, float, float, float, float) -> Tensor
    return _no_grad_trunc_normal_(tensor, mean, std, a, b)


def num_of_trainable_params(model):
    # type: (nn.Module) -> int
    model_parameters = filter(lambda p: p.requires_grad, model.parameters())
    num_params = sum([np.prod(p.size()) for p in model_parameters])
    return num_params


def clip_gradients(model, clip):
    # type: (nn.Module, float) -> List[float]
    # clip the gradient of each parameter by a scalar 'clip'
    norms = []
    for name, p in model.named_parameters():
        if p.grad is not None:
            param_norm = p.grad.data.norm(2)
            norms.append(param_norm.item())
            clip_coef = clip / (param_norm + 1e-6)
            if clip_coef < 1:
                p.grad.data.mul_(clip_coef)
    return norms


def cancel_gradients_last_layer(epoch, model, freeze_last_layer):
    # type: (int, nn.Module, int) -> None
    if epoch >= freeze_last_layer:
        return
    for n, p in model.named_parameters():
        if "last_layer" in n:
            p.grad = None


def has_batchnorms(model):
    # type: (nn.Module) -> bool
    bn_types = (torch.nn.modules.batchnorm._BatchNorm, nn.SyncBatchNorm)
    for name, module in model.named_modules():
        if isinstance(module, bn_types):
            return True
    return False


def get_params(cfg, model_list):
    # type: (CfgNode, List[nn.Module]) -> List[Dict[str, Any]]
    regularized = []
    regularized_dw = []
    not_regularized = []
    
    for model in model_list:
        for name, param in model.named_parameters():
            if not param.requires_grad:
                continue
            # scalar terms, e.g. bias, are not regularized
            if len(param.shape) == 1:
                not_regularized.append(param)
            # depthwise conv, not regularized in the final version (by setting cfg.SOLVER.WD_FACTOR_FOR_DW to zero)
            elif (len(param.shape) == 4) and (param.shape[1] == 1):
                regularized_dw.append(param)
            else:
                regularized.append(param)
    if len(regularized_dw) == 0:
        return [
            {'params': regularized}, 
            {'params': not_regularized, 'wd_factor': cfg.SOLVER.WD_FACTOR_FOR_BIAS, 'lars_exclude': cfg.SOLVER.LARS_EXCLUDE_BIAS}
        ]
    else:
        return [
            {'params': regularized}, 
            {'params': regularized_dw,  'wd_factor': cfg.SOLVER.WD_FACTOR_FOR_DW, 'lars_exclude': cfg.SOLVER.LARS_EXCLUDE_DW}, 
            {'params': not_regularized, 'wd_factor': cfg.SOLVER.WD_FACTOR_FOR_BIAS, 'lars_exclude': cfg.SOLVER.LARS_EXCLUDE_BIAS}
        ]



# def sub_filter_start_end(kernel_size, sub_kernel_size):
# 	center = kernel_size // 2
# 	dev = sub_kernel_size // 2
# 	start, end = center - dev, center + dev + 1
# 	assert end - start == sub_kernel_size
# 	return start, end


# def min_divisible_value(n1, v1):
# 	""" make sure v1 is divisible by n1, otherwise decrease v1 """
# 	if v1 >= n1:
# 		return n1
# 	while n1 % v1 != 0:
# 		v1 -= 1
# 	return v1


# def get_same_padding(kernel_size):
# 	if isinstance(kernel_size, tuple):
# 		assert len(kernel_size) == 2, 'invalid kernel size: %s' % kernel_size
# 		p1 = get_same_padding(kernel_size[0])
# 		p2 = get_same_padding(kernel_size[1])
# 		return p1, p2
# 	assert isinstance(kernel_size, int), 'kernel size should be either `int` or `tuple`'
# 	assert kernel_size % 2 > 0, 'kernel size should be odd number'
# 	return kernel_size // 2


# def gather_dw_weight(full_weight):
#     inc, _, h, w = full_weight.shape
#     index = torch.arange(start=0, end=inc, dtype=torch.long, device=full_weight.device)
#     index = torch.reshape(index, (inc, 1, 1, 1)).expand(inc, 1, h, w)
#     return torch.gather(full_weight, dim=1, index=index)


# def scatter_dw_weight(dw_weight, full_weight):
#     inc, _, h, w = dw_weight.shape
#     index = torch.arange(start=0, end=inc, dtype=torch.long, device=full_weight.device)
#     index = torch.reshape(index, (inc, 1, 1, 1)).expand(inc, 1, h, w)
#     return torch.scatter(full_weight, 1, index, dw_weight)


# def gather_group_weight(full_weight, sub_groups, channels_per_group):
#     sub_filters = torch.chunk(full_weight, sub_groups, dim=0)
#     sub_ratio = full_weight.size(1) // channels_per_group
#     filter_crops = []
#     for group_id, sub_filter in enumerate(sub_filters):
#         part_id = group_id % sub_ratio
#         start = part_id * channels_per_group
#         filter_crops.append(sub_filter[:, start:start + channels_per_group, :, :])
#     filters = torch.cat(filter_crops, dim=0)
#     return filters